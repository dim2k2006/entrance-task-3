# ШРИ 2017, Задание 3

## Описание

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать, 
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл. 
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.

## Решение

Для исправления работы офлайнового сценария были проведены следующие работы:

1. Файл service-worker.js был перенесен в корень проекта, для того чтобы сервис воркер имел контроль над всеми ресурсами приложения. 
2. Файл gifs.html был добавлен в список кешируемых ресурсов.
3. Исправлена обработка события fetch. В изначальном варианте файлы всегда брались из кеша. В исправленном варианте сначала происходит запрос к ресурсам и только потом обращение к кешу.
4. Также в качестве решения дополнительного задания, для того чтобы иметь возможность переключения в офлайн-режим после первого же запроса, было решено добавить кеширование всех ресурсов приложения в момент события install.

## Ответы на вопросы

### Вопрос №1: зачем нужен этот вызов?

```js
self.skipWaiting()
```

Данный метод предотвращает ожидание завершения работы старого сервис воркера. Благодаря этому новый сервис воркер начинает свою работу сразу после завершения установки.

### Вопрос №2: зачем нужен этот вызов?

```js
self.clients.claim();
```

По умолчанию сервис воркер получает контроль над ресурсами страницы только после перезагрузки данной страницы. Данный метод позволяет изменить данное поведение и сервис воркер получает контроль над ресурсами без перезагрузки страницы.

### Вопрос №3: для всех ли случаев подойдёт такое построение ключа?

```js
const cacheKey = url.origin + url.pathname;
```

Нет, не для всех. При наличии в адресе get параметров, они не будут учтены.

### Вопрос №4: зачем нужна эта цепочка вызовов?

```js
return Promise.all(
    names.filter(name => name !== CACHE_VERSION)
        .map(name => {
            console.log('[ServiceWorker] Deleting obsolete cache:', name);
            return caches.delete(name);
        })
);
```

Данная цепочка вызовов необходима для удаления предыдущей версии кеша.

### Вопрос №5: для чего нужно клонирование?

```js
response.clone()
```

Это обусловлено тем, что потоки запроса и ответа могут быть прочитаны только единожды. Чтобы ответ был получен браузером и сохранен в кеше — нужно клонировать его. Так, оригинальный объект отправится браузеру, а клон будет закеширован. Оба они будут прочитаны единожды.